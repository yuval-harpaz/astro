import os
from astro_utils import *
from astropy.time import Time
from astro_list_ngc import choose_fits, make_thumb, ngc_html_thumb
from glob import glob
from astro_ngc_align import add_crval_to_logs
from atproto import Client as Blient
from atproto import client_utils, models
from mastodon_bot import connect_bot

blient = Blient()
blient.login(os.environ['Bluehandle'], os.environ['Blueword'])
blim = 250  # should be 300 limit but failed once
masto, loc = connect_bot()
deband = True
highlight_url = 'https://yuval-harpaz.github.io/astro/jwst_highlights_gray.html'
def post_image(message, image_path, alt=None, mastodon=True, bluesky=True):
    """Post an image with a message to Mastodon and/or Bluesky.
    Args:
        message (str): The message to post. may contain a link that starts with http and ends with html
        image_path (str): The path to the image file.
        alt (str): Alt text for the image, if needed. When starts with chatGPT:, it will be replaced by the alt text generated by gptAlt.
        mastodon (bool): Whether to post to Mastodon.
        bluesky (bool): Whether to post to Bluesky.
    Returns:
        dict: A dictionary with the post results for each platform."""

    # toot = f"\U0001F916 image processing for NASA / STScI #JWST \U0001F52D data ({target}). RGB Filters: {filt_str}"
    # toot = toot + f"\nPI: {info['PI_NAME']}, program {info['PROGRAM']}. CRVAL: {np.round(hdr0['CRVAL1'], 6)}, {np.round(hdr0['CRVAL2'], 6)}"
    post = {}
    if bluesky:
        boot = client_utils.TextBuilder()
        txt = message
        # if len(txt) > blim:
        #     txt = txt[:blim]
        if 'http' in message and 'html' in message:
            txt1 = txt[:txt.index('http')]
            txt2 = txt[txt.index('html')+4:]
            link_str = txt[txt.index('http'):txt.index('html')+4]
            if len(txt1)+len(txt2) > blim:
                txt1 = txt1[:blim]
            boot.text(txt1)
            boot.link(link_str.split('/')[-1], link_str)
            boot.text(txt2)
        else:
            boot.text(txt)
        try:
            with open(image_path, 'rb') as f:
                img_data = f.read()
            if type(alt) is str and alt[:8] == 'chatGPT:':
                try:
                    from gptAlt import gpt_alt_text
                    alt = gpt_alt_text(image_path, prompt=alt)
                    if alt[:9] == 'Alt Text:':
                        alt = alt[9:].strip()
                        alt = 'chatGPT: ' + alt
                except Exception as e:
                    print(f"Error generating alt text with OpenAI: {e}")
                    alt = None
                
            if alt is None:
                alt = image_path.split('/')[-1]
            post['bsky'] = blient.send_image(text=boot, image=img_data, image_alt=alt)
            # success += 'bsky;'
            print('boot image')
        except:
            print(f'failed bluesky post for {image_path}')
    if mastodon:
        try:
            metadata = masto.media_post(image_path, "image/jpeg")
            post['masto'] = masto.status_post(message, media_ids=metadata["id"])
            print('toot image')
        except:
            print(f'failed mastodon post for {image_path}')
    return post


def reply_to_post(post, text=None, link=None):
    """Reply with a link to a post with an image."""
    if text is None:
        text = '123 test'
    boot = client_utils.TextBuilder()
    boot = boot.text(text)
    if link is not None:
        boot.link(link[0], link[1])
    parent = models.create_strong_ref(post)
    root = models.create_strong_ref(post)
    rep = blient.send_post(
        text=boot,
        reply_to=models.AppBskyFeedPost.ReplyRef(parent=parent, root=root)
    )
    return rep
##
if __name__ == '__main__':
    df = pd.read_csv('ngc.csv', sep=',')
    # drive = '/media/innereye/KINGSTON/JWST/'
    ##
    if os.path.isdir('/home/innereye'):
        path2astro ='/home/innereye/astro'
        path2logs = path2astro+'/logs/'
        path2thumb = path2astro+'/docs/thumb/'
        if not os.path.isdir(drive):
            raise Exception('where is the drive?')
    else:
        print(os.getcwdb())
        drive = os.getcwdb().decode('utf-8')  # os.environ['HOME']+'/astro'
        path2logs = drive+'/logs/'
        path2thumb = drive+'/docs/thumb/'
        path2astro = drive
    os.chdir(drive)
    ##
    last_post_row = np.where((df['posted'].str.contains('http')) | (df['posted'].values == 'failed'))[0][0]
    if last_post_row == 0:
        print(f"last NGC already posted ({df['target_name'][last_post_row]})")
    else:
        for row in range(last_post_row):
            pkl = False
            tgt = df['target_name'][row]
            try:
                os.chdir(drive)
                date0 = df["collected_from"][row][:10]
                log_csv = f'{path2logs}{tgt}_{date0}.csv'
                already = glob('/home/innereye/astro/docs/thumb/'+date0+'_'+tgt+'*')
                forbidden = False
                if 'TRAPEZIUM-CLUSTER-P1_2022-09-26.csv' in log_csv:  # too large
                    forbidden = True
                if forbidden:
                    print('forbidden: ' + date0 + '_' + tgt)
                else:
                    both_apart = False  # no overlap between MIRI and NIRCam
                    if tgt == 'NGC-6822-MIRI-TILE-2-COPY' or tgt == 'NGC-346-TILE-6':
                        both_apart = True
                    if 'background' in tgt.lower() or 'BKG' in tgt:
                        print('no background for now '+tgt)
                    else:
                        if not os.path.isdir('data'):
                            os.system('mkdir data')
                        if not os.path.isdir('data/' + tgt):
                            os.system('mkdir data/' + tgt)
                        t_min = [np.floor(Time(df['collected_from'][row]).mjd),
                                    np.ceil(Time(df['collected_to'][row]).mjd)]
                        args = {'target_name': tgt,
                                't_min': t_min,
                                'obs_collection': "JWST",
                                'calib_level': 3,
                                'dataRights': 'public',
                                'intentType': 'science',
                                'dataproduct_type': "image"}
                        table = Observations.query_criteria(**args)
                        isnotnirspec = np.array(['NIRSPEC' not in x.upper() for x in table['instrument_name']])
                        isnotniriss = np.array(['NIRISS' not in x.upper() for x in table['instrument_name']])
                        table = table[isnotnirspec & isnotniriss]
                        if os.path.isfile(log_csv):
                            download_by_log(log_csv, tgt=tgt)
                            chosen_df = pd.read_csv(log_csv)
                        else:
                            files = list(table['obs_id'])
                            files = [x + '_i2d.fits' for x in files]
                            print(f'[{row}] downloading {tgt} by query')
                            download_fits_files(files, destination_folder='data/' + tgt, wget=False)
                            chosen_df = choose_fits(files, folder='data/' + tgt)
                            if all(chosen_df['chosen']):
                                filtnum = filt_num(chosen_df['file'].values)
                                order = np.argsort(filtnum)
                                chosen_df = chosen_df.iloc[order]
                            else:
                                chosen_chosen = chosen_df[chosen_df['chosen'] == True]
                                not_chosen = chosen_df[chosen_df['chosen'] == False]
                                df2 = [chosen_chosen, not_chosen]
                                for idf in [0, 1]:
                                    filtnum = filt_num(df2[idf]['file'].values)
                                    order = np.argsort(filtnum)
                                    df2[idf] = df2[idf].iloc[order]
                                chosen_df = pd.concat(df2)
                            chosen_df.to_csv(log_csv, index=False, sep=',')
                        ## make image
                        # read the files and for each filter, choose smaller and close to target images
                        use = chosen_df['chosen'].to_numpy()
                        files = np.asarray(chosen_df['file'])
                        # see if we have both MIRI and NIRCam, choose RGB method accordingly
                        files = files[use]
                        filt = filt_num(files)
                        files = files[np.argsort(filt)]
                        filt = np.sort(filt)
                        mn = np.zeros((len(files),2))
                        for ii in range(len(files)):
                            if 'miri' in files[ii]:
                                mn[ii,0] = 1
                            if 'nircam' in files[ii]:
                                mn[ii,1] = 1
                            if mn[ii, :].sum() == 0:
                                print('no miri and no nircam '+files[ii])
                                mn[ii, :] = np.nan
                            elif mn[ii, :].sum() == 2:
                                raise Exception('both miri and nircam')
        
                        method = 'rrgggbb'
                        if np.nanmean(mn[:, 0]) == 1:
                            instrument = 'MIRI'
                        elif np.nanmean(mn[:,1]) == 1:
                            instrument = 'NIRCam'
                        else:
                            instrument = 'NIRCam+MIRI'
                            method = 'mnn'
                        os.chdir('data')# os.chdir('..')
                        plotted = []
                        # TODO decide if to use 0.5 1 1
                        made_png = False
                        if np.nansum(mn[:, 0]) >= 2:
                            output_jpg = tgt+'_MIRI.jpg'
                            make_image = True
                            if os.path.isfile(drive+'data/'+tgt+'/'+output_jpg):
                                remake = input(f"File {output_jpg} already exists. Do you want to remake it? (y/n): ")
                                if remake.lower() != 'y':
                                    make_image = False
                                    os.chdir(drive+'/data/'+tgt)
                            if make_image:
                                auto_plot(tgt, exp=list(files[mn[:, 0] == 1]), png=output_jpg, pkl=pkl, method='rrgggbb', fill=True, adj_args={'factor':1}, deband=True)
                            else:
                                os.chdir(drive+'/data/'+tgt)
                            plotted.append(output_jpg)
                            made_png = True
                        if np.nansum(mn[:,1]) >= 2:
                            output_jpg = tgt+'_NIRCam.jpg'
                            make_image = True
                            if os.path.isfile(drive+'data/'+tgt+'/'+output_jpg):
                                remake = input(f"File {output_jpg} already exists. Do you want to remake it? (y/n): ")
                                if remake.lower() != 'y':
                                    make_image = False
                                    os.chdir(drive+'/data/'+tgt)
                            if make_image:
                                img = auto_plot(tgt, exp=list(files[mn[:, 1] == 1]), png=output_jpg, pkl=pkl, method='rrgggbb', fill=True, adj_args={'factor':1}, deband=deband)
                                img = grey_zeros(img, replace=np.max)
                                plt.imsave(output_jpg, img, origin='lower')
                            plotted.append(output_jpg)
                            made_png = True
                        if '+' in instrument and np.nansum(mn) >= 2 and not both_apart:
                            if not os.path.isfile('nooverlap.txt'):
                                try:
                                    output_jpg = tgt+'_'+instrument+'.jpg'
                                    make_image = True
                                    if os.path.isfile(drive+'data/'+tgt+'/'+output_jpg):
                                        remake = input(f"File {output_jpg} already exists. Do you want to remake it? (y/n): ")
                                        if remake.lower() != 'y':
                                            make_image = False
                                            os.chdir(drive+'/data/'+tgt)
                                    if make_image:
                                        auto_plot(tgt, exp=list(files[~np.isnan(mn[:, 0])]), png=output_jpg, pkl=pkl, method='mnn', fill=True, adj_args={'factor':1}, deband=None)
                                    plotted.append(output_jpg)
                                    made_png = True
                                except:
                                    print('no overlap???????????????')
                                    # os.system('echo "no overlap" > nooverlap.txt')
                        ##
                        if made_png:
                            path2images = make_thumb(plotted, date0, path2thumb=path2thumb)
                            ipic = -1
                            for pic in plotted:
                                ipic += 1
                                # message = f"testing new code, processing JWST STScI data for {tgt} {pic.split('_')[-1][:-4]}"
                                # toot = toot + f"\nPI: {info['PI_NAME']}, program {info['PROGRAM']}. CRVAL: {np.round(hdr0['CRVAL1'], 6)}, {np.round(hdr0['CRVAL2'], 6)}"
                                img = plt.imread(pic)
                                path2resize = resize_jpg_to_1mb(pic)
                                # path_to_1M = path2images[ipic].split('/')[-1].replace('.jpg', '_1M.jpg')
                                # plt.imsave(path_to_1M, img, pil_kwargs={'quality': 95})
                                hdu = fits.open(chosen_df['file'][0])
                                crval1 = hdu[1].header['CRVAL1']
                                crval2 = hdu[1].header['CRVAL2']
                                message = f'\U0001F916 processing for highlight #JWST \U0001F52D {instrument} data, target name: {tgt}.'  # .\nCredit: NASA, ESA, CSA, STScI.\nTake a look at {url}'
                                message = message + f'\nPI: {table["proposal_pi"][0]}, program {table["proposal_id"][0]}. CRVAL: {np.round(crval1, 6)}, {np.round(crval2, 6)}'
                                message = message + f'\nCredits: NASA, ESA, CSA, STScI.'
                                message = message + f'\nSee more highlights at {highlight_url}.'
                                alt = f'chatGPT: Generate Alt Text for JWST {instrument} image of {tgt}.'
                                post = post_image(message, path2resize, alt=alt, mastodon=True, bluesky=True)
                                if 'masto' in post.keys():
                                    url = post['masto']['url']+';'
                                else:
                                    url = ''
                                if 'bsky' in post.keys():
                                    url = url + 'https://bsky.app/profile/astrobotjwst.bsky.social/post/'+post['bsky']['uri'].split('/')[-1] + ';'
                                url = url[:-1]
                            df.at[row, 'posted'] = url
                            df.to_csv(path2astro+'/ngc.csv', index=False)
                            print('DONE ' + date0 + '_' + tgt)
                        else:
                            print('no plots for '+ date0 + '_' + tgt)
                            df.at[row, 'posted'] = 'failed'
                            df.to_csv(path2astro+'/ngc.csv', index=False)
            except Exception as error:
                print('FAILED '+tgt)
                print(error)
                break
        add_crval_to_logs(path2astro=path2astro, drive=drive)


# print('trying sending to oshi')
# err = os.system(f"curl -T {pic} https://oshi.ec > tmp.txt")
# if err:
#    print('error sending to oshi')
#else:
# print('sent to oshi')
#with open('tmp.txt', 'r') as tmp:
#    dest = tmp.read()
#download_link = dest.split('\n')[2].split(' ')[0]
#print(dest)
#print(f"sent {pic} to: {download_link}")
# text = 'A high resolution image will be available for a few days at '
# link = ['https://oshi.ec', download_link]
# rep = reply_to_post(post, text, link)
